\name{compileGPUKernel}
\alias{compileGPUKernel}
\alias{fixPTXCodeForNVVM}
\alias{ModuleForNVVM}
\alias{setGPUKernel}
\alias{DefaultGPULayout}
\title{Compile an R function as a GPU kernel}
\description{
  These functions and objects allow us to compile an R function
  into PTX code so that it can be used as a GPU kernel, i.e.
  run on a GPU.

  \code{compileGPUKernel} maps the R code to GPU instructions.

  \code{ModuleForNVVM} creates an LLVM Module for housing Functions and
  variables. This sets the appropriate information for the Module to be
  used for a Nvidia GPU, setting the data layout information for the
  different basic data types.

  \code{setGPUKernel} adds an \code{nnvm.annotations} attribute to each of the
  functions. This is used by libNVVM when creating the final usable code
  for the GPU.

  \code{fixPTXCodeForNVVM} is used to post-process generated code
  so that it can be then used by the libNVVM mechanism.
}
\usage{
compileGPUKernel(fun, types, module = ModuleForNVVM(name), name = NULL,
                 .compilerHandlers = getGPUCompilerHandlers(), .insertReturn = TRUE,
                  .builtInRoutines = getGPUBuiltInRoutines(), .useFloat = TRUE, ...)
fixPTXCodeForNVVM(code)
setGPUKernel(funs, module)
}
\arguments{
  \item{fun}{the R function to map to GPU instructions}
  \item{types}{type information for the parameters and return value}
  \item{module}{the LLVM module in which the Function is to be (or was)
    created.   For  \code{setGPUKernel}, this can be missing and so obtained from the first Function.}
  \item{name}{the name of the newly created LLVM/compiled Function}
  \item{.compilerHandlers}{the collection of "methods"/functions that
        constitute the compiler. These handle the different constructs in
       the R code and map them to GPU}
  \item{.insertReturn}{a logical value controlling whether we should
    pre-process the R code to insert the explicit \code{return}
    calls. This simplifies the job of the individual handler functions.}
  \item{.builtInRoutines}{a list describing built-in routines that may
    be referenced.}
   \item{.useFloat}{a logical value. This controls whether we use double
   or float data type for numeric variables.}
   \item{\dots}{additional arguments passed directly to
     \code{\link{compileFunction}}}
   \item{code}{a character string containing the PTX code generated by compiling code for the GPU}
   \item{funs}{a list of LLVM Function objects}
 }
\value{
  The newly created \code{Function} object, i.e. the LLVM routine.
}
\references{LLVM, libNVVM}
\author{Duncan Temple Lang}
%\note{}

\seealso{
\code{\link{compileFunction}}
}
%\examples{}
\keyword{programming}
\concept{compilation}
\concept{high performance computing}
