<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- <?xml-stylesheet type="text/xsl" href="../org/omegahat/Docs/XSL/Todo.xsl" ?> -->
<?xml-stylesheet type="text/xsl" href="../../Classes/StatComputing/XDynDocs/inst/XSL/OmegahatXSL/Todo.xsl" ?>

<topics xmlns:r="http://www.r-project.org" xmlns:c="http://www.c.org"
	xmlns:r="http://www.r-project.org">

<topic>
<title>General</title>

<items>

<item>
Process the .supportFunctionInfo in compileFunction.
</item>

<item>
Calls to other functions, e.g. log or printf.
<br/>
Use codetools to find these before we start compiling.
Get their types. Allow as parameter in compileFunction.
</item>


<item>
Returning R objects.
Write values into R objects ?
</item>

<item>
Split the incrementing in a loop into its own condition so that
we can jump to that block of code for a continue.
<br/>
Done, but giving wrong result for continue.
See loop.next
</item>

<item>
Unary logical operator !
</item>

<item>
We just return the function now and not the module
as we can get the module from the function with 
<r:expr>as(fun, "Module").</r:expr>
</item>

<item>
The type of the logical in the branch is wrong.
See the rep function
<r:expr>a = compileFunction(rep, Int32Type)</r:expr>
</item>

<item>
Finish off next and break handlers.
Specifically, have the while and for loops 
register then .nextBlock and .continueBlock.
Put these on a stack.
</item>

<item>
Implement repeat
</item>

<item>
Handle cases where R doesn't return anything explicitly, i.e. just NULL implicitly, but we need
a particular type, e.g. an integer in 

<r:code>
foo = function(x) if(x < 10) 100L
</r:code>
At least identify these for the person calling compile and ask for a default
value. <r:na/> can work for certain types.
</item>

<item>
Create temporary variable for if statements 
when we assign the value to a variable in R, e.g.

<r:code>
x = if(a < 1) "abc" else "def"
</r:code>
Need to store the value from the expressions
in the bodies of the if statement.
</item>

<item>
Handle implicit return.
</item>

<item>
[ operator for simple vectors.
<br/>
Have to be aware of factor, Date and POSIXt types.
</item>
<item>
[ operator for matrices
</item>

<item>
[ for data frame.
<br/>
Get the variable then [] on the vector.
We can hope the LLVM optimizer will 

</item>

<item>
Consolidate the 2 getLimits functions.
</item>

<item>
May want to simplify compile() and not call getArgs() and pass them to
the handler funcition - call.op. Many of the handlers will need the entire call.
</item>

<item>
The for loop, like the if, needs to know where to branch to.  So it
needs the next.  It can create a new Block and refer to it.  Then the
next expression being compiled can just write to that without having
to even worry.  So we don't need to create the blocks for each
expression and pass the nextBlock argument.
</item>

<item>
Need a function to give the name of an available temporary variable
for our function we are compiling.
</item>

<item>
Handle no explicit return() in the code
</item>

<item>
Add connections to the different blocks, i.e.
 when generate code for one block and then another
 add a branch from the first to the next.

    getBlocks() gives us the blocks for a function.

  We probably
</item>

<item>
Memory management
</item>
</items>
</topic>

</topics>

