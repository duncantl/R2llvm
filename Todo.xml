<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="Admin/XSL/Todo.xsl" ?>

<topics xmlns:r="http://www.r-project.org" xmlns:c="http://www.c.org">

<topic>
<title>General</title>

<items>
<item status="done">
How to make the global native variable in R R_GlobaEnv
available to the module.
AddSymbol? declare it locally?
<br/>
Seem to need $address rather than just getNativeSymbolInfo().
</item>

<item>
Generate error or warning when use a wrong variable.
If we change r_ans to rans in callRFunction.R on the LHS of the Rf_eval,
then we just get the wrong answer.
It is legitimate as we created the local variable (why did we need it?)
</item>

<item>
Extend globalCallSEXP.R to process the return value.
</item>

<item status="done">
Get the globalCallSEXP.R sorted out.
Problem with Rcall variable not being resolved.
But the code in globalArray.R  does work.
The Rcall declaration has an "external" qualifier.
Is this because it is a pointer? because it has no initializer?
The latter, so use ConstantPointerNull.
</item>

<item>
Callbacks to R
explorations/simpleCallback.R and explorations/conCall.R
</item>

<item status="high"> 
Element subsetting with a data frame.
See dataFrameSubset.R
</item>

<item>
Recognize to compile <r:expr>sapply(v, `[[`, 1)</r:expr>,
i.e. to rewrite this  either as a loop over v and insert  
<r:expr>el[[i]]</r:expr> or to rewrite this as
<r:expr>sapply(v, function(x) x[[1]])</r:expr>.
The former is nicer as it is essentially inlining the body of the function.
</item>

<item status="high">
Rather than having the createLoopCode() check to see if 
compile.if (or any other compile method) has made the incrBlock
the current insertion block. If it has, then createLoopCode  needs to avoid 
adding the branch instruction. But really, the other methods should try to 
aoid changing the insertion block except into blocks that they created.
</item>

<item status="done">
Doug Bate's Rgibbs example is giving NaNs
</item>

<item status="done">
[Done but see above]Compile Doug Bate's Rgibbs example
<br/>
It involves matrix subset assignment, and combining values on the RHS of the assignment.
<br/>
Assignment seems to work and looping fine. But the values we get are  NaN.
First few are not, but then they go nuts.
</item>

<item>
Add optional bounds checking on <r/> objects when subsetting.
Allow the caller to add hints to the compiler to say check these variables, but not these.
Also, develop static analysis to identify which ones go over bounds, if possible.
</item>

<item status="high">
Test subsetting with a list(). Simple accessing an element. Then assign to an element.
Need to  know the type of the element unless we use run-time information.
Try
<r:code>
x = replicate(N, list(a = 2, b = 3))
sapply(x, function(x) x[[1]])
</r:code>
Don't use names ("a"), but position.
</item>

<item satus="done">
Need a SEXP type for lists.
<br/>
Use VECSXPType. Same as getSEXPType("VEC").
</item>

<item>
Really want to be able to distinguish between REALSXPType and INTSXPType.
</item>

<item status="verify">
[Works now] Error in insertReturn when expecting a return value but none
<r:code>
f = function(x, i) { el = x[[i]]}
fc = compileFunction(f, Int32Type, list(SEXPType, Int32Type))
</r:code>
</item>

<item>
Constant folding.
Arises in matrix subsetting in SEXP.R around line 60 when we create 2L - 1L.
We know this is 1L.
For 1L -1L convert this to 0 but recognize that we don't have to do the multiplication.
Also, When one operand in multiplication is 1, don't do the multiplication.
When adding, if one of the operands is 0, don't do the addition.
</item>

<item>
When do constant folding elimination for arithmetic, i.e. remove a mult/dv or an add/sub since it is the same value,
we  need to eliminate/remove the previously compiledinstructions.
<br/>
We may want to compile the operands sequentially and check after the first one to see if it or the second one is necessary,
in contrast to lapply() to compile them both and then examine.
</item>


<item>
Eliminate dead code. Does LLVM do this for us?
See explorations/mathElim.R.
We eliminate the addition. But we leave the n = 0, i.e. the store instruction.
Is this a case where a compiler pass would be useful.
</item>


<item>
<br/>
When doing arithmetic such as 2 - 1L, recognize that the 2 is an integer value
(not type). Add parameter/flag to compile for arithmetic to say make the result an integer.
When computing the index for subsetting, we'd activate this.
So in <r:expr>x[2, i]</r:expr> we want 2 - 1L to be an integer.
</item>


<item status="high">
Compute the REAL(x) pointer just once for a matrix.
See matrixElAssign.Rdb.
Similarly, compute Rf_nrow(), etc. just once.
But detect if the value could change.
</item>

<item status="high">
Handle the <r:expr>pragma(IfAssign, var, updatedExpressions)</r:expr>
</item>

<item status="check">
Handle assignments from RHS being if-else
<r:code>
z = if(cond) val1 else val2
</r:code>
See 2DRandomWalk.Rdb.
<br/>
Either have  the assignment determine that the RHS is complicated 
or have the RHS's compile method return information about the two branches.
In either case, this <r:expr>assignHandler = `compile.=` = </r:expr>
method for the compiler needs to understand that this is special and requires
modifying the code. (Same for ifelse).
Need to ensure the types from the two branches are the same.
<br/>
IMPORTANT: we have the ifAssign.R file for rewriting if statements.
[Done] FIX THIS:  see inst/examples/ifAssign.R and specifically bar.
And export these functions and use them in compile.
Also, we may want to "declare" variable before the if. But don't know its type there.
But we can go back and set it
</item>

<item>
getBlocks() seg faults.
2DRandomWalk.Rdb in the if handler.
</item>

<item status="news">
Do we have functions in Rllvm to get the current block, i.e. the block with the insertion point?
Yes  getInsertBlock()
</item>

<item>
Why are we exiting out of R when a module is not valid? Would like to get an error in R.
See 2DRandomWalk.Rdb.
</item>

<item>inbounds for accessing elements of an array.
Rllvm now has isInBounds methods to query and set.
</item>

<item status="done">byval for parameters when passing a struct object directly to a routine. explorations/clangHandler2.R
<br/>
See call.R::callHandler.  Need to determine which argument has a byval attribute.
How do we query this?
<r:code>
arg = mod$clang_CXCursor_getName[[1]]
hasByValAttr(arg)
</r:code>
But it appears we don't need to set this if the declaration of the Function
has this information.
</item>

<item status="verify">
In tests/structByVal.R, if we don't have the return(2L), we get an error about no terminator.
<br/>
This seems to work again. But I saw it in globalArrayAccessors.R once after this.
So perhaps some memory problem in Rllvm.
</item>

<item>
What is .vectorize  doing? Does it actually generate vectorized code.
</item>

<item>
tests/ with a XXX or a FIX
vectorize.R  character3.R
<br/>
Fixed: structByVal.R  globalArrayAccessors.R
</item>

<item>
Add a mechanism to differentiate between integer() 
meaning INTSXPType or Int32Type in R code.
</item>

<item>
Test the other code now that we switched load = TRUE for subsetHandler
</item>

<item>
Compile rw2d
<br/>
See tests/2DRandomWalk.Rdb
<br/>
Didn't we do this for the StatSci paper? Yes, but manually.
</item>

<item>
Compile vectorized fibonacci (Rllvm/explorationts/fib.R)
and compare with closed form solution approach.
</item>

<item>
handle case of serial assignment
<r:code>
xpos = ypos = numeric(n)
</r:code>
to ensure create a new vector.
Do we do this for the SEXP types, i.e. call Rf_duplicate() when assigning.
</item>

<item>
Get native version of nrow(), ncol() that don't
use a SEXP.
Can implement directly ourselves as C routines.
Nice to compile them however.
</item>

<item>
When we call any of the constructor functions, i.e. numeric(), etc.
protect the result and unprotect them at the end.
</item>

<item status="done">
Allocate the variables within a loop outside of the loop just once.
<br/>
Could be smarter about this. Currently doing it for ever variable.
But only needs to be done for a  loop.
</item>

<item>
When we have a REALSXPType and access its elements,
create a local variable and initialize it with a call to REAL().
Then use that in place of the REALSXPType variable.
</item>

<item>
Compile closures with shared state. See R/compileClosures.R
Use RCIndex collectors as examples, or SAX handlers.
First compile  the functions, ignoring the global variables and get
them to work.
Use clone() to copy the module for a new instance. In other words,
the call to the generator function is just a call to clone of the
routines.
</item>

<item>
Recognize/identify idioms of the form
<r:code>
 x = c()
 for(i in z) 
    x = c(x, f(i))
</r:code>
The key is the declaration of an empty vector and then
concatenating it with a single value.
</item>

<item>
Problem with  looping from 1:n and subsetting using i - 1L.
When we have nested loops,  i + j doesn't correspond to the correct element
See tests/convolve.R
We can work with two variables - i and i.index/i.offset and use them for different purposes,
i.e i.offset for subsetting.
</item>

<item>
When compiling expr = expr, pass the 
type of the LHS to compile.call, and generically to compile
as, say, targetType.  Alternatively, we can just  cast the result
when assigning to the LHS.
</item>

<item status="done">
Get the numeric() example in tests/numeric.R  working.
</item>

<item>
Consolidate the code in compile.= and call.R for numeric(), etc.
and the isPrimitiveConstructor() and compilePrimitiveConstructor()
and how we rewrite to do the Rf_allocVector in call.R
</item>

<item>
Deal with closures within a function. Create global variables in the module ?
</item>

<item>
Recognize x[i] for a SEXPType and change this to be work on x.els and 
compute the pointer first as a local variable.
</item>

<item status="done">
map functions to other names in a call, e.g. length to Rf_length and then compile.
May want to check we are dealing with a SEXPType.
</item>

<item>
Check in the loops that we are getting the limits correct.
In explorations/sapply.R in Rllvm/ we are not doing the last element correctly.
Interaction issue here as subsetting subtracts off the 1 which may be necessary to do 
since not always in a loop.
</item>

<item>
recognize function names in calls to sapply.
It would be okay if we rewrote the sapply() calls before determining
the global variables.
</item>

<item>
There is some inelegancy in handling return(sapply(...)) 
when we do the rewrite of sapply(). 
It would be nice to do the rewrite explicitly and so remove the
return(sapply(....)).
In fact, we actually add it and then remove it.
But there is knowledge in the rewrite about the name of the variable
and actually returning it.
</item>

<item>
Separate storing the type for a variable and creating
it. In rewriteSApply(), we set the type for r_ans, but we haven't 
created it.  So keep track of which variables we have created.
</item>

<item>
In the code we generate for rewriteSApply(), the generic compile() function
doesn't dispatch to the methods for <![CDATA[compile.<-]]> and compile.for.
Instead, they go to call. Yet the class seems to be correct. However
they are created programmatically with quote(), etc.
I have put in a mechanism to do this dispatch explicitly in compile.call.
</item>

<item>
When calling a function, perform a cast for the arguments if they are not of the correct
type.
e.g. STRING_ELT(a, 0) and STRING_ELT(a, 0L). The latter works, but the former doesn't.
</item>

<item>
[*] Implement assignment to accessor for a STRSXP. assignToSEXPElement
See tests/SEXPStringSubset.R
</item>
<item>
Sort out a mechanism for dealing with more specific SEXP types
and not matching the types when calling functions with more
specific types.
</item>

<item status="done">
Can't add x[1] + 20L when passing in an INTSXPType.
Need to implement the getTypeOfElement for SEXPType types.
tests/SEXPSubset.R.
<br/>
Problem was that x[i] wasn't understanding SEXPs as special and working with the pointer to the sxpinfo_struct.
</item>

<item>
We need to know what the target/output type of an expression
such as x[i] is when we x is a SEXP type.
Is it the raw element or is it a SEXP subset, i.e. an integer() vector.
We know this from the context, potentially.
<br/>
Added a SEXPToPrimitive, but not using it yet.
</item>

<item status="done">
Problems with casting when returning an element of a REALSXP as a DoubleType.
tests/SEXPSubset.R
Are we treating the x as a pointer to an array of structs, i.e SEXP*
and so getting it all wrong.
So we need to know that these are SEXPTypes and work differently with these.
Same as for assignment. See getElementAssignmentContainerType
</item>


<item>
Fix the casting of the x[i] = 20 in SEXPSubset example.
Currently need 20L, but should be able to handle this.
</item>

<item>
[Added some support to subtract 1 via subractOne()]
One- and zero-based indexing.
Could do a rewrite of the expression.
Also could just subtract 1 from the expression.
</item>

<item>
Handle subsetting generally, non-integer values and strings and vectors.
</item>

<item status="done">
Subsetting with x[2] (any literal) fails. Need to make the literal into an integer.
See R/subset.R
</item>

<item>
Allow fun[["n"]] retrieve the parameter named n in fun.
Do we store the names?
</item>

<item>
Recognize a = if() x else y and map to a select/ternary operation.
</item>

<item>
Map switch() in R to a switch in LLVM when the conditions are integers.
Also recognize an series of if() statements.
</item>

<item>
introduce declarations as R functions, e.g. strPointer(tmp)
which then creates a local variable tmp of type pointerType(StringType).
Also concepts such as positiveInt(), nonNegInt(), unsignedInt().
These functions would do nothing and so can stay in code that is interpreted.
</item>

<item status="done">
See tests/character*.R
compile references to character() to be the NULL string, i.e. 0.
<r:code>
library(RLLVMCompile)
f = function() { x = character() ; 1L}
fc = compileFunction(f, Int32Type)
</r:code>
</item>

<item id="multiCond" status="high">
Multiple conditions in a test, i.e. if and while condition
<r:code><![CDATA[
f = function(x, y)
{
  ans = 0L
  if(x < 0 || y < 10 || y > 100)  #x + y == 0)
      ans = 3L
  else
      ans = 7L
 
  return(ans)
}
fc = compileFunction(f, Int32Type, list(x = Int32Type, y = Int32Type))
]]></r:code>
How do we represent these - test each separately and branch for each or combine the operations and test the overall result?
For || the second approach won't work as we don't want to evaluate the RHS.
Checking with  how llvm does it on a .c file, it is the multi branch/block setup.
</item>

<item>
When comparing to a literal and the literal has an integer value,
don't use a double/floating point comparison when the other value is an integer, e.g.
<r:code>
if(i &lt; 2) ...
</r:code>
then the compiler currently treats 2 as a numeric, not an integer and promotes i.
</item>

<item>
Is the code generated for the tests/simpleFor.R correct?
It works, but the incrementing of the loop counter is in the body.
Also, the condition block has an extra instruction that seems irrelevant.
<pre>
%3 = load i32* %ctr
</pre>
</item>

<item status="high">
Create a class and constructor to represent the compiler.
(Maybe a reference class).
Then allow this to be reused to compile different functions.
</item>

<item>
Type inference system needed.
See RTypeInference on github.
</item>

<item>
Explore why the fuseLoop example with fc for f2 segfaults when we have a vector of length 1e6 rather than 1e5
</item>

<item>
Call R functions from C code.
<br/>
Can construct the expression in the compiled code, if we have access to the
routines in R.
Alternatively, compile the R function and just call that.
</item>

<item>
Explore non-standard evaluation.
</item>

<item>
Allow caller of compile to customize the code
to a particular data frame or set of inputs, e.g. to
map names to positions just once, e.g.
<r:code>
data$var1[1:n]
data[1:n, "var1"]
</r:code>
would look up the index of var1 and replace "var1" with its index.
(Or use a hash table to represent the data structure.)
</item>

<item>
Support compiling for code with NAs or without, i.e.
allow the caller of compileFunction to specify whether
to include code for NAs.
<br/>
There is a parameter for this in compileFunction.
Is it used? No, at this moment. April 17th.
Basically, we ignore NAs entirely.
</item>

<item>
Support creating code for vectors or scalars,
i.e. different code that takes a vector and iterates over that or
 a function/routine that takes a scalar.
These are qualitatively different routines.
</item>

<item>
Should we use a fixed variable name for the return value.
Then all code could store that and jump  to final block.
</item>

<item status="done">
Compile ! 
<r:code>
library(RLLVMCompile)
h = function(l) !l
hun = compileFunction(h, Int32Type, Int32Type)
.llvm(hun, 1)
</r:code>
This creates an xor.
<br/>
[Fixed] Now fails but in better place. Tries to cast Int1Type to Int32Type.
Write the code for this in utils.R (in RLLVMCompile) to handle this.
<br/>
Works but <r:expr>.llvm(hun, 0)</r:expr> gives -1. 
What should it give us.  See tests/not.R
</item>

<item>
Identify const variables.
This is for our purpose rather than LLVM. We want to be able to identify
these to determine whether we can pass them by reference since they don't change.
</item>

<item status="done">
Identify constants  such as pi in dnorm calculation.
If the current value is in a sealed package and is a numeric value,
then could treat this as constant, heuristically.
Replace in the code.
</item>

<item>
If code refers to a non-local variable, either capture that variable now
and convert it to a value in the module or insert a call to a routine
to get the variable. We can then generate a routine in the module that
retrieves the current value of the R object from the R interpreter.
<br/>
Add a parameter to compileFunction that controls whether we do this
aggressive capture or lazy lookup at call time.
</item>

<item>
Compute types for the intrinsics and put in a table
so that the R user doesn't have to specify them.
Does this make sense, i.e. for the overloaded ones?
</item>

<item>
Rewrite expressions. 
Do we use a separate pass?
Or do we make the changes as we try to compile a call, e.g. replace pi with the constant,
replace  expr^2 with pow(expr, 2). (Ideally, we'd create a temporary variable for expr and
then multiply.)
</item>

<item>
Handle x[1:10], i.e. x[vector] and x[vector] = value(s).
</item>

<item>
Compile the not() function to test the ! operator.
<br/>
Which not() function. See below for a function(x) !x.
</item>

<item status="check">
Logical data type - Int1Type.
</item>

<item>
Does run() in Rllvm return the mutable parameters?
</item>

<item status="note">
The OPS table/list is now called CompilerHandlers
and it can be customized for a call to 
compileFunction by copying that object and
inserting new elements or replacing existing ones.
</item>

<item status="note">
One can control which functions are compiled
by specifying <r:arg>.globals</r:arg>.
</item>

<item>
Handle default values for parameters in R functions.
<br/>
We can compile the code just before the first 
expression at which that parameter is referenced.
<br/>
Need to know about missing. This is a feature of the call.
We can add a parameter to the target function .missing as a vector
and then add this in each call.  Then we can test this in the code
and conditionally evaluate the default value.
</item>

<item>
Handle named arguments and match them during compilation
and reorder. Don't worry about
any assignments  in the expressions which might
make the order important
e.g.
<r:code><![CDATA[
  foo(b = (num <- sum(x)), a = integer(num))
]]></r:code>
This is suicidal code anyhow and 
there is no guarantee b will be evaluated before a
due to lazy evaluation.
</item>

<item status="done">
Allow the caller of compileFunction to specify their own
version of .compilerHandlers to customize how the
code generation operates.
</item>

<item>
Implement the for loop of the form for(i in x) 
by introducing a loop counter, say, .i
and add a new instruction to load x[i].
</item>

<item>
Implement R's switch().
</item>

<item status="done">
Have the supportFunctionInfo split for external routines
and one that we compile ourselves.
<br/>
If the called functions have type information, then we can compile
them. But allow this to be specified by the caller of compileFunction.
<br/>
Or do type inference.
</item>

<item status="check">
Compiling other R functions we reference.
Compile function tries to do this.
</item>


<item status="done">
Process the .supportFunctionInfo in compileFunction.
</item>

<item status="partial">
Calls to other functions, e.g. log or printf.
<br/>
Use codetools to find these before we start compiling.
Get their types. Allow as parameter in compileFunction.
<br/>
See test.R and the example loop.next and printi
</item>

<item>
An R object (function probably) that
can arrange to load the external symbols before calling run,
i.e. the functions we call that we don't compile.
<br/>
asFunction in compileFunction causes the return of a function.
We can add the names of the external routines to the environment
and arrange to load those when the function is invoked, even
just the first time..
</item>


<item>
Returning R objects.
<br/>
We strip away the SEXP and pass the data to our new routines.
How do we return these as SEXPs, e.g. put them back into
a (new) SEXP.  Rllvm does this for us. But we may want to
take this over as we can.
<br/>
We might want to allocate the space before the call and have
our new routine write into that. Need to avoid duplicating
in the call to run.
<br/>
See how we can do this with a special object with  class
that we return from compileFunction.
</item>

<item>
Memory management
</item>

<item status="done">
Split the incrementing in a loop into its own condition so that
we can jump to that block of code for a continue.
<br/>
Done, but giving wrong result for continue.
See loop.next
</item>

<item>
Unary logical operator !. A good way to do this would be use LLVM's
XOR op with 1.
</item>

<item status="done">
We just return the compiled function or the R function now and not the module
as we can get the module from the function with 
<r:code>as(fun, "Module")</r:code>
Also, <r:expr>showModule(fun) </r:expr> works without any
need to explicitly coerce the function to a module.
</item>

<item status="done">
The type of the logical in the branch is wrong.
See the rep function
<r:code>a = compileFunction(rep, Int32Type)</r:code>
</item>

<item status="check">
Finish off next and break handlers.
Specifically, have the while and for loops 
register then .nextBlock and .continueBlock.
Put these on a stack.
</item>

<item status="check">
Implement repeat
</item>

<item>
Handle cases where R doesn't return anything explicitly, i.e. just NULL implicitly, but we need
a particular type, e.g. an integer in 
<r:code><![CDATA[
foo = function(x) if(x < 10) 100L
]]></r:code>
At least identify these for the person calling compile and ask for a default
value. <r:na/> can work for certain types.
<br/>
See insertReturn in utils.R.
This will work for simple cases. But not for  cases with if, while,
for. Here we will have to jump out of those local blocks and then return
from the routine.  So we will need to change the code that would return to assign to a
fixed variable (e.g. .return) and then jump to the end block
</item>

<item status="check">
Create temporary variable for if statements 
when we assign the value to a variable in R, e.g.

<r:code><![CDATA[
x = if(a < 1) "abc" else "def"
]]></r:code>
Need to store the value from the expressions
in the bodies of the if statement.
<br/>
Code is in ifAssign.R to rewrite these expressions.
Now done automatically in 
</item>



<item>
[ operator for simple vectors.
<br/>
Have to be aware of factor, Date and POSIXt types.
</item>
<item>
[ operator for matrices
</item>

<item>
[ for data frame.
<br/>
Get the variable then [] on the vector.
We can hope the LLVM optimizer will 

</item>

<item>
Consolidate the 2 getLimits functions.
</item>

<item status="done">
May want to simplify compile() and not call getArgs() and pass them to
the handler function - call.op. Many of the handlers will need the entire call.
</item>

<item status="done">
The for loop, like the if, needs to know where to branch to.  So it
needs the next.  It can create a new Block and refer to it.  Then the
next expression being compiled can just write to that without having
to even worry.  So we don't need to create the blocks for each
expression and pass the nextBlock argument.
</item>

<item>
Need a function to give the name of an available temporary variable
for our function we are compiling.
</item>

<item status="done">
Handle no explicit return() in the code
i.e. 
<r:code>
function() { 
  x = 1
  y = 2
  x + y
}
</r:code>
where the last expression is the return value.
See the <r:pkg>TypeInfo</r:pkg> package for how we do this.
</item>

<item status="done">
Add connections to the different blocks, i.e.
 when generate code for one block and then another
 add a branch from the first to the next.

    getBlocks() gives us the blocks for a function.

</item>

<item> 
Handle vectorized operations of ==, +, !, etc.
</item>

<item> 
Handle unary "-".
</item>

<item status="done">
Add returning correct Null in R_Module_getGlobalVariable in Rllvm so
assignHandler gets to second condition.
</item>


<item>
Check for return - lacking return cases Rllvm to hardcrash, i.e.

<r:code>
function(x) {
  if (!x)
    return(3L)
}
</r:code>
</item>


</items>
</topic>
<topic>
<title>Type Inference</title>
<items>
<item>
Identify const variables.
</item>

<item>
When compiling a function and we are given its types, follow those
through the expressions to determine the types of local variables and
also then follow calls to other functions and determine the types of
those calls and so recursively follow the expressions in those other
functions.
</item>

<item>
Figure out the output from a function based on its inputs
and the functions it calls.
</item>

<item status="ok">
Handle variable reassignment; possibly by using a strategy of renaming
variables. Are arguments immutable? Should this be treated exactly as
it is in R?
<r:code><![CDATA[
t2 <- function(x) {
  y <- 4L
  x <- y
  return(x)
}
]]></r:code>
<r:code>
ff = compileFunction(t2, DoubleType, DoubleType)
.llvm(ff, 3)
</r:code>
</item>


<item status="done">
If the  return type is VoidType, don't bother with the .insertReturn
See Dnorm_v
</item>

<item status="done">
When we find the free variables, check if they exist before
generating any code and report errors immediately.
</item>
<item status="done" note="works for fib example">
Handle case when an expression is an if() and both branches return.
Need to kill off the "next" block since there isn't one.

See fib
<r:code>
library(RLLVMCompile)
fib =
function(n)
{
  if(n == 0L || n == 1L)
     n
  else
     fib(n - 1L) + fib(n - 2L)
}
fc = compileFunction(fib, Int32Type, list(n = Int32Type), name = "fib")
</r:code>
</item>

<item status="done">
insertReturn for fib function above.
Adding .ret and not return() for the else expression.
<br/>
Check we haven't broken anything else related to insertReturn.
</item>

<item status="done">
Issues with createNeg. 
<r:code>
library(RLLVMCompile)
f = function(n)
{
  return( - n)
}
fc = compileFunction(f, Int32Type, list(n = Int32Type))
</r:code>
Broken module.
Do we need to load n first?
</item>

<item status="done">
The initial assignment to ans doesn't compile
<r:code>
f = function()
{
  ans = -1L 
  return(ans)
}
</r:code>
We can handle this as a literal value and assign the value directly
after evaluating it in R. Done.
<br/>
<r:error>cannot createNeg for this type yet.</r:error>
Now need a method for createNeg which is in Rllvm,
but we need a version .
Compiles now, but get a bad module.
</item>

</items>
</topic>
</topics>

