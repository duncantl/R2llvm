<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="../OmegahatXSL/XSL/OmegahatXSL/Todo.xsl" ?>

<topics xmlns:r="http://www.r-project.org" xmlns:c="http://www.c.org">

<topic>
<title>General</title>

<items>
<item>
Implement assignment to accessor for a STRSXP.
assignToSEXPElement
</item>

<item>
Can't add x[1] + 20L when passing in an INTSXPType.
Need to implement the getTypeOfElement for SEXPType types.
tests/SEXPSubset.R
</item>

<item>
We need to know what the target/output type of an expression
such as x[i] is when we x is a SEXP type.
Is it the raw element or is it a SEXP subset, i.e. an integer() vector.
We know this from the context, potentially.
</item>

<item>
Problems with casting when returning an element of a REALSXP as a DoubleType.
tests/SEXPSubset.R
Are we treating the x as a pointer to an array of structs, i.e SEXP*
and so getting it all wrong.
So we need to know that these are SEXPTypes and work differently with these.
Same as for assignment. See getElementAssignmentContainerType
</item>


<item>
Fix the casting of the x[i] = 20 in SEXPSubset example.
Currently need 20L, but should be able to handle this.
</item>

<item>
[Added some support to subtract 1 via subractOne()]
One- and zero-based indexing.
Could do a rewrite of the expression.
Also could just subtract 1 from the expression.
</item>

<item>
Handle subsetting generally, non-integer values and strings and vectors.
</item>

<item status="done">
Subsetting with x[2] (any literal) fails. Need to make the literal into an integer.
See R/subset.R
</item>

<item>
Allow fun[["n"]] retrieve the parameter named n in fun.
Do we store the names?
</item>

<item>
Recognize a = if() x else y and map to a select/ternary operation.
</item>

<item>
Map switch() in R to a switch in LLVM when the conditions are integers.
Also recognize an series of if() statements.
</item>

<item>
introduce declarations as R functions, e.g. strPointer(tmp)
which then creates a local variable tmp of type pointerType(StringType).
Also concepts such as positiveInt(), nonNegInt(), unsignedInt().
These functions would do nothing and so can stay in code that is interpreted.
</item>

<item status="done">
See tests/character*.R
compile references to character() to be the NULL string, i.e. 0.
<r:code>
library(RLLVMCompile)
f = function() { x = character() ; 1L}
fc = compileFunction(f, Int32Type)
</r:code>
</item>

<item id="multiCond" status="high">
Multiple conditions in a test, i.e. if and while condition
<r:code><![CDATA[
f = function(x, y)
{
  ans = 0L
  if(x < 0 || y < 10 || y > 100)  #x + y == 0)
      ans = 3L
  else
      ans = 7L
 
  return(ans)
}
fc = compileFunction(f, Int32Type, list(x = Int32Type, y = Int32Type))
]]></r:code>
How do we represent these - test each separately and branch for each or combine the operations and test the overall result?
For || the second approach won't work as we don't want to evaluate the RHS.
Checking with  how llvm does it on a .c file, it is the multi branch/block setup.
</item>


<item>
Create a class and constructor to represent the compiler.
(Maybe a reference class).
Then allow this to be reused to compile different functions.
</item>

<item>
Type inference system needed.
See RTypeInference on github.
</item>

<item>
Explore why the fuseLoop example with fc for f2 segfaults when we have a vector of length 1e6 rather than 1e5
</item>

<item>
Call R functions from C code.
<br/>
Can construct the expression in the compiled code, if we have access to the
routines in R.
Alternatively, compile the R function and just call that.
</item>

<item>
Explore non-standard evaluation.
</item>

<item>
Allow caller of compile to customize the code
to a particular data frame or set of inputs, e.g. to
map names to positions just once, e.g.
<r:code>
data$var1[1:n]
data[1:n, "var1"]
</r:code>
would look up the index of var1 and replace "var1" with its index.
(Or use a hash table to represent the data structure.)
</item>

<item>
Support compiling for code with NAs or without, i.e.
allow the caller of compileFunction to specify whether
to include code for NAs.
<br/>
There is a parameter for this in compileFunction.
Is it used? No, at this moment. April 17th.
Basically, we ignore NAs entirely.
</item>

<item>
Support creating code for vectors or scalars,
i.e. different code that takes a vector and iterates over that or
 a function/routine that takes a scalar.
These are qualitatively different routines.
</item>

<item>
Should we use a fixed variable name for the return value.
Then all code could store that and jump  to final block.
</item>

<item status="done">
Compile ! 
<r:code>
library(RLLVMCompile)
h = function(l) !l
hun = compileFunction(h, Int32Type, Int32Type)
.llvm(hun, 1)
</r:code>
This creates an xor.
<br/>
[Fixed] Now fails but in better place. Tries to cast Int1Type to Int32Type.
Write the code for this in utils.R (in RLLVMCompile) to handle this.
<br/>
Works but <r:expr>.llvm(hun, 0)</r:expr> gives -1. 
What should it give us.  See tests/not.R
</item>

<item>
Identify const variables.
This is for our purpose rather than LLVM. We want to be able to identify
these to determine whether we can pass them by reference since they don't change.
</item>

<item status="done">
Identify constants  such as pi in dnorm calculation.
If the current value is in a sealed package and is a numeric value,
then could treat this as constant, heuristically.
Replace in the code.
</item>

<item>
If code refers to a non-local variable, either capture that variable now
and convert it to a value in the module or insert a call to a routine
to get the variable. We can then generate a routine in the module that
retrieves the current value of the R object from the R interpreter.
<br/>
Add a parameter to compileFunction that controls whether we do this
aggressive capture or lazy lookup at call time.
</item>

<item>
Compute types for the intrinsics and put in a table
so that the R user doesn't have to specify them.
Does this make sense, i.e. for the overloaded ones?
</item>

<item>
Rewrite expressions. 
Do we use a separate pass?
Or do we make the changes as we try to compile a call, e.g. replace pi with the constant,
replace  expr^2 with pow(expr, 2). (Ideally, we'd create a temporary variable for expr and
then multiply.)
</item>

<item>
Handle x[1:10], i.e. x[vector] and x[vector] = value(s).
</item>

<item>
Compile the not() function to test the ! operator.
<br/>
Which not() function. See below for a function(x) !x.
</item>

<item status="check">
Logical data type - Int1Type.
</item>

<item>
Does run() in Rllvm return the mutable parameters?
</item>

<item status="note">
The OPS table/list is now called CompilerHandlers
and it can be customized for a call to 
compileFunction by copying that object and
inserting new elements or replacing existing ones.
</item>

<item status="note">
One can control which functions are compiled
by specifying <r:arg>.globals</r:arg>.
</item>

<item>
Handle default values for parameters in R functions.
<br/>
We can compile the code just before the first 
expression at which that parameter is referenced.
<br/>
Need to know about missing. This is a feature of the call.
We can add a parameter to the target function .missing as a vector
and then add this in each call.  Then we can test this in the code
and conditionally evaluate the default value.
</item>

<item>
Handle named arguments and match them during compilation
and reorder. Don't worry about
any assignments  in the expressions which might
make the order important
e.g.
<r:code><![CDATA[
  foo(b = (num <- sum(x)), a = integer(num))
]]></r:code>
This is suicidal code anyhow and 
there is no guarantee b will be evaluated before a
due to lazy evaluation.
</item>

<item status="done">
Allow the caller of compileFunction to specify their own
version of .compilerHandlers to customize how the
code generation operates.
</item>

<item>
Implement the for loop of the form for(i in x) 
by introducing a loop counter, say, .i
and add a new instruction to load x[i].
</item>

<item>
Implement R's switch().
</item>

<item status="done">
Have the supportFunctionInfo split for external routines
and one that we compile ourselves.
<br/>
If the called functions have type information, then we can compile
them. But allow this to be specified by the caller of compileFunction.
<br/>
Or do type inference.
</item>

<item status="check">
Compiling other R functions we reference.
Compile function tries to do this.
</item>


<item status="done">
Process the .supportFunctionInfo in compileFunction.
</item>

<item status="partial">
Calls to other functions, e.g. log or printf.
<br/>
Use codetools to find these before we start compiling.
Get their types. Allow as parameter in compileFunction.
<br/>
See test.R and the example loop.next and printi
</item>

<item>
An R object (function probably) that
can arrange to load the external symbols before calling run,
i.e. the functions we call that we don't compile.
<br/>
asFunction in compileFunction causes the return of a function.
We can add the names of the external routines to the environment
and arrange to load those when the function is invoked, even
just the first time..
</item>


<item>
Returning R objects.
<br/>
We strip away the SEXP and pass the data to our new routines.
How do we return these as SEXPs, e.g. put them back into
a (new) SEXP.  Rllvm does this for us. But we may want to
take this over as we can.
<br/>
We might want to allocate the space before the call and have
our new routine write into that. Need to avoid duplicating
in the call to run.
<br/>
See how we can do this with a special object with  class
that we return from compileFunction.
</item>

<item>
Memory management
</item>

<item status="done">
Split the incrementing in a loop into its own condition so that
we can jump to that block of code for a continue.
<br/>
Done, but giving wrong result for continue.
See loop.next
</item>

<item>
Unary logical operator !. A good way to do this would be use LLVM's
XOR op with 1.
</item>

<item status="done">
We just return the compiled function or the R function now and not the module
as we can get the module from the function with 
<r:code>as(fun, "Module")</r:code>
Also, <r:expr>showModule(fun) </r:expr> works without any
need to explicitly coerce the function to a module.
</item>

<item status="done">
The type of the logical in the branch is wrong.
See the rep function
<r:code>a = compileFunction(rep, Int32Type)</r:code>
</item>

<item status="check">
Finish off next and break handlers.
Specifically, have the while and for loops 
register then .nextBlock and .continueBlock.
Put these on a stack.
</item>

<item status="check">
Implement repeat
</item>

<item>
Handle cases where R doesn't return anything explicitly, i.e. just NULL implicitly, but we need
a particular type, e.g. an integer in 
<r:code><![CDATA[
foo = function(x) if(x < 10) 100L
]]></r:code>
At least identify these for the person calling compile and ask for a default
value. <r:na/> can work for certain types.
<br/>
See insertReturn in utils.R.
This will work for simple cases. But not for  cases with if, while,
for. Here we will have to jump out of those local blocks and then return
from the routine.  So we will need to change the code that would return to assign to a
fixed variable (e.g. .return) and then jump to the end block
</item>

<item status="check">
Create temporary variable for if statements 
when we assign the value to a variable in R, e.g.

<r:code><![CDATA[
x = if(a < 1) "abc" else "def"
]]></r:code>
Need to store the value from the expressions
in the bodies of the if statement.
<br/>
Code is in ifAssign.R to rewrite these expressions.
Now done automatically in 
</item>



<item>
[ operator for simple vectors.
<br/>
Have to be aware of factor, Date and POSIXt types.
</item>
<item>
[ operator for matrices
</item>

<item>
[ for data frame.
<br/>
Get the variable then [] on the vector.
We can hope the LLVM optimizer will 

</item>

<item>
Consolidate the 2 getLimits functions.
</item>

<item status="done">
May want to simplify compile() and not call getArgs() and pass them to
the handler function - call.op. Many of the handlers will need the entire call.
</item>

<item status="done">
The for loop, like the if, needs to know where to branch to.  So it
needs the next.  It can create a new Block and refer to it.  Then the
next expression being compiled can just write to that without having
to even worry.  So we don't need to create the blocks for each
expression and pass the nextBlock argument.
</item>

<item>
Need a function to give the name of an available temporary variable
for our function we are compiling.
</item>

<item status="done">
Handle no explicit return() in the code
i.e. 
<r:code>
function() { 
  x = 1
  y = 2
  x + y
}
</r:code>
where the last expression is the return value.
See the <r:pkg>TypeInfo</r:pkg> package for how we do this.
</item>

<item status="done">
Add connections to the different blocks, i.e.
 when generate code for one block and then another
 add a branch from the first to the next.

    getBlocks() gives us the blocks for a function.

</item>

<item> 
Handle vectorized operations of ==, +, !, etc.
</item>

<item> 
Handle unary "-".
</item>

<item status="done">
Add returning correct Null in R_Module_getGlobalVariable in Rllvm so
assignHandler gets to second condition.
</item>


<item>
Check for return - lacking return cases Rllvm to hardcrash, i.e.

<r:code>
function(x) {
  if (!x)
    return(3L)
}
</r:code>
</item>


</items>
</topic>
<topic>
<title>Type Inference</title>
<items>
<item>
Identify const variables.
</item>

<item>
When compiling a function and we are given its types, follow those
through the expressions to determine the types of local variables and
also then follow calls to other functions and determine the types of
those calls and so recursively follow the expressions in those other
functions.
</item>

<item>
Figure out the output from a function based on its inputs
and the functions it calls.
</item>

<item status="ok">
Handle variable reassignment; possibly by using a strategy of renaming
variables. Are arguments immutable? Should this be treated exactly as
it is in R?
<r:code><![CDATA[
t2 <- function(x) {
  y <- 4L
  x <- y
  return(x)
}
]]></r:code>
<r:code>
ff = compileFunction(t2, DoubleType, DoubleType)
.llvm(ff, 3)
</r:code>
</item>


<item status="done">
If the  return type is VoidType, don't bother with the .insertReturn
See Dnorm_v
</item>

<item status="done">
When we find the free variables, check if they exist before
generating any code and report errors immediately.
</item>
<item status="done" note="works for fib example">
Handle case when an expression is an if() and both branches return.
Need to kill off the "next" block since there isn't one.

See fib
<r:code>
library(RLLVMCompile)
fib =
function(n)
{
  if(n == 0L || n == 1L)
     n
  else
     fib(n - 1L) + fib(n - 2L)
}
fc = compileFunction(fib, Int32Type, list(n = Int32Type), name = "fib")
</r:code>
</item>

<item status="done">
insertReturn for fib function above.
Adding .ret and not return() for the else expression.
<br/>
Check we haven't broken anything else related to insertReturn.
</item>

<item status="done">
Issues with createNeg. 
<r:code>
library(RLLVMCompile)
f = function(n)
{
  return( - n)
}
fc = compileFunction(f, Int32Type, list(n = Int32Type))
</r:code>
Broken module.
Do we need to load n first?
</item>

<item status="done">
The initial assignment to ans doesn't compile
<r:code>
f = function()
{
  ans = -1L 
  return(ans)
}
</r:code>
We can handle this as a literal value and assign the value directly
after evaluating it in R. Done.
<br/>
<r:error>cannot createNeg for this type yet.</r:error>
Now need a method for createNeg which is in Rllvm,
but we need a version .
Compiles now, but get a bad module.
</item>

</items>
</topic>
</topics>

